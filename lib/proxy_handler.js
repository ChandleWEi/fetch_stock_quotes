// Generated by CoffeeScript 1.3.3
(function() {
  var env, http, jsdom, logger, mysql, request, test_proxy, verify_proxies;

  http = require('http');

  http.globalAgent.maxSockets = 10;

  request = require('request');

  logger = require('./logger');

  mysql = require('./db').mysql;

  env = require('./config/environment');

  jsdom = require('jsdom');

  jsdom.defaultDocumentFeatures = {
    FetchExternalResources: false,
    ProcessExternalResources: false
  };

  verify_proxies = function(response, query) {
    var get_total_count_sql;
    get_total_count_sql = "select count(*) as count from http_proxies";
    mysql.query(get_total_count_sql, null, function(err, results) {
      var completed_count, get_proxy_sql, proxy_count_per_request, step, total_count, _ref, _results;
      if (err) {
        console.error("[mysql error] Count http_proxies failed for " + err);
        return response.end();
      } else {
        total_count = results[0].count;
        console.log("[mysql http_proxies_total_count] " + total_count);
        _ref = [0, 0, 1], step = _ref[0], completed_count = _ref[1], proxy_count_per_request = _ref[2];
        if (total_count > 0) {
          _results = [];
          while (true) {
            console.log(" loop ... loop ...");
            get_proxy_sql = "select id, ip, country, port from http_proxies limit " + proxy_count_per_request + " offset " + (step * proxy_count_per_request);
            mysql.query(get_proxy_sql, null, function(error, rs) {
              var available, chinese_hot_key, cookie, country, id, ip, j, port, update_proxy_sql, url;
              if (error) {
                return console.log("[mysql error] Get http proxy to verify failed for " + error);
              } else {
                if (typeof rs[0] === "undefined") {
                  console.error("[mysql error] http proxies table is blank");
                  console.log(" direct return ... ");
                  return;
                }
                update_proxy_sql = "update http_proxies set available = ?, verified_at = now() where id = ?";
                id = rs[0].id;
                ip = rs[0].ip;
                country = rs[0].country;
                port = rs[0].port;
                console.log("ip: " + ip + ":" + port + ", country: " + country);
                available = false;
                chinese_hot_key = env.CHINESE_HOT_KEYS.sort(function() {
                  return 0.5 - Math.random();
                })[4];
                console.log(" hot key: " + chinese_hot_key);
                url = (function() {
                  switch (country) {
                    case 1:
                      return "http://www.google.com.au/search?q=" + chinese_hot_key;
                    default:
                      return "http://s.weibo.com/weibo/" + chinese_hot_key + "&xsort=time&Refer=STopic_box";
                  }
                })();
                j = request.jar();
                cookie = request.cookie("" + (Math.random()) + "myr@nd0mYUEWR" + (Math.random()));
                j.add(cookie);
                return request.get({
                  uri: url,
                  proxy: "http://" + ip + ":" + port,
                  timeout: 30000,
                  headers: {
                    "User-Agent": "Safari 10.2"
                  },
                  jar: j
                }, function(error, res, body) {
                  var feasible;
                  feasible = false;
                  if (error || typeof res === "undefined") {
                    if (error) {
                      console.error("[proxy request error] " + error);
                    }
                    if (typeof res === "undefined") {
                      console.error("response undefined ...");
                    }
                    return mysql.query(update_proxy_sql, [feasible, id], function(err, results) {
                      if (err) {
                        return console.log("[mysql error] update http_proxies#" + id + " available failed for " + err);
                      }
                    });
                  } else {
                    console.log("[proxy statuscode] " + (typeof res.statusCode) + " " + res.statusCode);
                    if (res.statusCode === 200) {
                      return jsdom.env({
                        html: body
                      }, function(error, window) {
                        var match, reg_pat;
                        if (error) {
                          feasible = false;
                          console.log(" ------ jsdomerror ----- " + error);
                        } else {
                          reg_pat = /veri_code/m;
                          match = reg_pat.exec(body);
                          if (match === null) {
                            feasible = true;
                          } else {
                            feasible = false;
                          }
                        }
                        window.close();
                        return mysql.query(update_proxy_sql, [feasible, id], function(err, results) {
                          if (err) {
                            return console.log("[mysql error] update http_proxies#" + id + " available failed for " + err);
                          }
                        });
                      });
                    }
                  }
                });
              }
            });
            step++;
            if (step * proxy_count_per_request >= total_count) {
              break;
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        }
      }
    });
    return response.end();
  };

  test_proxy = function(response, query) {
    var get_proxy_sql;
    response.writeHeader(200, {
      "Content-Type": "text/html"
    });
    get_proxy_sql = "select id, ip, country, port from http_proxies where available = true order by speed limit 1";
    return mysql.query(get_proxy_sql, null, function(error, rs) {
      var chinese_hot_key, cookie, country, id, ip, j, port, url;
      if (error) {
        return console.log("[mysql error] Get http proxy to verify failed for " + error);
      } else {
        if (typeof rs[0] === "undefined") {
          response.write("no available proxy");
          return response.end();
        }
        id = rs[0].id;
        ip = rs[0].ip;
        country = rs[0].country;
        port = rs[0].port;
        response.write("ip: " + ip + ":" + port + ", country: " + country + " \n");
        chinese_hot_key = env.CHINESE_HOT_KEYS.sort(function() {
          return 0.5 - Math.random();
        })[4];
        url = (function() {
          switch (country) {
            case 1:
              return "http://www.google.com.au/search?q=" + chinese_hot_key;
            default:
              return "http://s.weibo.com/weibo/" + chinese_hot_key + "&xsort=time&Refer=STopic_box";
          }
        })();
        j = request.jar();
        cookie = request.cookie("" + (Math.random()) + "myr@nd0mYUEWR" + (Math.random()));
        j.add(cookie);
        return request.get({
          uri: url,
          proxy: "http://" + ip + ":" + port,
          timeout: 30000,
          headers: {
            "User-Agent": "Safari 10.2"
          },
          jar: j
        }, function(error, res, body) {
          if (error) {
            response.write("[proxy response error] " + error + " \n");
          }
          if (typeof res === "undefined") {
            response.write("response is undefined \n");
          } else {
            response.write("[proxy statuscode] " + (typeof res.statusCode) + " " + res.statusCode + " \n");
            if (!error && res.statusCode === 200) {
              jsdom.env({
                html: body
              }, function(error, window) {
                var match, reg_pat;
                if (error) {
                  console.error("[proxy:error] can't get " + tag + " total count");
                } else {
                  reg_pat = /veri_code/m;
                  match = reg_pat.exec(body);
                  if (match === null) {
                    response.write("可用\n");
                  } else {
                    response.write("不可用\n");
                  }
                }
                return window.close();
              });
              response.write(body);
            }
          }
          return response.end();
        });
      }
    });
  };

  exports.verify_proxies = verify_proxies;

  exports.test_proxy = test_proxy;

}).call(this);
